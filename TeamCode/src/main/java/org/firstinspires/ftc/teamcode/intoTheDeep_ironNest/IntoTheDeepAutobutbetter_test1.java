package org.firstinspires.ftc.teamcode.intoTheDeep_ironNest;import com.qualcomm.robotcore.eventloop.opmode.Autonomous;import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;import com.qualcomm.robotcore.hardware.DcMotor;import com.qualcomm.robotcore.hardware.Servo;import com.qualcomm.robotcore.util.ElapsedTime;@Autonomous (name = "into the deep-sleeping auto")public class  IntoTheDeepAutobutbetter_test1 extends LinearOpMode {    DcMotor sliders;    Servo secondaryArm;    Servo claw;    int maxPosition = -975;    public int slider_position;    public double F;    public double f = (float) 0.0000005;    DcMotor wheel_1;    DcMotor wheel2;    DcMotor wheel4;    DcMotor wheel3;    double tilesToTicks = 537.7*(120*2*0.254*3.14);    int rotation_distance = 9;    double turning_number = ((double) rotation_distance /24)*537.7*(120*2*0.254*3.14);    Servo tertiary_arm;    void STOP(){        wheel_1.setPower(0);        wheel2.setPower(0);        wheel3.setPower(0);        wheel4.setPower(0);    }    void GO_Forward(double power){        wheel_1.setPower(-power);        wheel2.setPower(power);        wheel3.setPower(-power);        wheel4.setPower(-power);    }    void Go_backwards(double power){        wheel_1.setPower(power);        wheel2.setPower(-power);        wheel3.setPower(power);        wheel4.setPower(power);    }    void Turn_Right(){        wheel_1.setTargetPosition((int) turning_number);        wheel2.setTargetPosition((int) turning_number);        wheel3.setTargetPosition((int) -turning_number);        wheel4.setTargetPosition((int) turning_number);        wheel4.setMode(DcMotor.RunMode.RUN_TO_POSITION);        wheel3.setMode(DcMotor.RunMode.RUN_TO_POSITION);        wheel2.setMode(DcMotor.RunMode.RUN_TO_POSITION);        wheel_1.setMode(DcMotor.RunMode.RUN_TO_POSITION);        wheel_1.setPower(0.5);        wheel2.setPower(0.5);        wheel3.setPower(0.5);        wheel4.setPower(0.5);    }    @Override    public void runOpMode() throws InterruptedException {        claw = hardwareMap.get(Servo.class, "claw");        sliders = hardwareMap.get(DcMotor.class, "primary_arm");        secondaryArm = hardwareMap.get(Servo.class, "secondaryArm");        wheel_1 = hardwareMap.get(DcMotor.class, "left_front_drive");        wheel2 = hardwareMap.get(DcMotor.class, "right_back_drive");        wheel4 = hardwareMap.get(DcMotor.class, "right_front_drive");        wheel3 = hardwareMap.get(DcMotor.class, "left_back_drive");        sliders.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        sliders.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        wheel_1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        wheel_1.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        wheel2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        wheel2.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        wheel3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        wheel3.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        wheel4.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        wheel4.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        waitForStart();//        while (opModeIsActive()) {//            int currentPosition = sliders.getCurrentPosition();//            if (currentPosition >= maxPosition) {//                sliders.setPower(-0.5);//            }else {3//                sliders.setPower(0);//            }//        /}        while (opModeIsActive()) {            claw.setPosition(1);            secondaryArm.setPosition(0.25);            slider_position = sliders.getCurrentPosition();            F = slider_position * f;            while (slider_position >= maxPosition && opModeIsActive()) {                slider_position = sliders.getCurrentPosition();                F = slider_position * f;                sliders.setPower(-0.5 + F);                telemetry.addData("F", F);                telemetry.addData("wheels", wheel2.getCurrentPosition());                telemetry.update();            }            sliders.setPower(F);            while (wheel2.getCurrentPosition() < 0.013 * tilesToTicks && opModeIsActive()) {                GO_Forward(0.5);            }            claw.setPosition(0.65);            while (wheel2.getCurrentPosition() > 0 && opModeIsActive()) {                Go_backwards(0.5);            }            STOP();            Turn_Right();            STOP();            sleep(6000);            ElapsedTime timer = new ElapsedTime();            while (timer.seconds() < 1.5) {                wheel_1.setPower(-0.75);                wheel2.setPower(0.75);                wheel3.setPower(0.75);                wheel4.setPower(0.75);            }            wheel_1.setPower(0.75);            wheel2.setPower(-0.75);            wheel3.setPower(-0.75);            wheel4.setPower(-0.75);            break;        }    }}